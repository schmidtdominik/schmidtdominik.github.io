<!DOCTYPE html>
<html lang="en">
<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>Category Theory - Dominik Schmidt</title>
  <meta name="author" content="Dominik Schmidt">
  <meta name="theme-color" content="#52D681"/>

  <link rel=preload href="../css/BIG JOHN.otf" as="font" crossorigin>

  <meta property="og:title" content="Category Theory"/>
  <meta property='og:type' content='article'/>
  <meta property="og:image" content="assets/cover.png"/>
  <meta property="og:url" content="http://dominikschmidt.xyz/category-theory-notes"/>
  <!--<meta property="og:description" content="These are my lecture notes on Bartosz Milewski's course on category theory. These are not meant as a comprehensive guide but rather a loose collection of definitions and short summaries."/>-->

  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
  <script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
  <script>
  window.addEventListener("load", function(){
  window.cookieconsent.initialise({
    "palette": {
      "popup": {
        "background": "#edeff5",
        "text": "#838391"
      },
      "button": {
        "background": "#4b81e8"
      }
    },
    "position": "bottom-left",
    "content": {
      "href": "http://dominikschmidt.xyz/policy"
    }
  })});
  </script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123900161-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-123900161-1');
  </script>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-4694920180315448",
            enable_page_level_ads: true
       });
  </script>

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <script defer src="https://use.fontawesome.com/releases/v5.12.0/js/all.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
           CommonHTML: {
             scale: (MathJax.Hub.Browser.isChrome ? 100 : 100)
           }
         });


  </script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>


  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="stylesheet" href="../css/normalize.css">
  <link rel="stylesheet" href="../css/skeleton.css">
  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/article.css">

  <link rel="stylesheet" href="../highlight/styles/atom-one-light.css"><!--foundation/hopscotch-->
  <script src="../highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="../images/favicon.png">

  <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">window.dojoRequire(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us19.list-manage.com","uuid":"728374c3215a28cdf09e2b11c","lid":"eeb0dbccb1","uniqueMethods":true}) })</script>
</head>
<body>

  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div class="container">
    <div class="row">
      <div style="margin-top: 8%">
          <h1>
            <a href="../index.html">
              <span id="title">
                Dominik Schmidt
              </span>
            </a>
            <!--<a href="index.html">
              <span id="by-me">

              </span>
            </a>-->
          </h1>
        <hr>
        <nav>
          <span style="display: inline-block;" ><a class="navitem" href="../index.html"><i class="far fa-newspaper"></i>&nbsp;Reads</a></span>
          <span style="display: inline-block;" ><a class="navitem" href="../datasets.html"><i class="fas fa-sitemap"></i>&nbsp;Datasets</a></span>
          <span style="display: inline-block;" ><a class="navitem" href="../random.html"><i class="fas fa-robot"></i>&nbsp;Random Stuff</a></span>
          <span style="display: inline-block;" ><a class="navitem" href="../about.html"><i class="fas fa-map-marker-alt"></i>&nbsp;About me</a></span>

          <span class="navwrapper" style="float: right"><a class="navitem" style="margin-right: 1.6rem;" href="https://github.com/schmidtdominik"><i class="fab fa-github"></i>&nbsp;</a></span>
          <!--<span class="navwrapper" style="float: right"><a class="navitem" style="margin-right: 1.6rem;" href="https://www.reddit.com/user/dominik_schmidt"><i class="fab fa-reddit"></i></i>&nbsp;</a></span>-->
        </nav>
      </div>
    </div>
  </div>

  <div class="container article">
      <div id='header-box'>


        <!--START OF HEADING-->
        <div style="display:flex;justify-content:center;align-items:center;">
          <img src="assets/cover.png" id="header-img" alt="">
        </div>


        <div id="header-text">
          <h1 class="article-title">
            Category Theory
          </h1>
          <time datetime="2019-12-29 00:00:00">December 29, 2019 ⧗ 19 minute read</time><br>
        </div>
      </div>
      <!--END OF HEADING-->

      <span class="article-text">
        <div id="index"><a href=#general-stuff> → General stuff</a><br><a href=#set> → Set</a><br><a href=#category-theory-in-programming> → Category Theory in Programming</a><br><a href=#the-empty-set>&emsp; → The Empty Set</a><br><a href=#the-singleton-set>&emsp; → The Singleton Set</a><br><a href=#the-two-element-set>&emsp; → The Two-Element Set</a><br><a href=#hask>&emsp; → Hask</a><br><a href=#weak-and-strong-typing>&emsp; → Weak and Strong Typing</a><br><a href=#other-categories> → Other Categories</a><br><a href=#the-category-\varnothing>&emsp; → The Category \(\varnothing\)</a><br><a href=#free-categories>&emsp; → Free Categories</a><br><a href=#monoids>&emsp; → Monoids</a><br><a href=#thin-categories>&emsp; → Thin Categories</a><br><a href=#orders>&emsp; → Orders</a><br><a href=#kleisli-categories>&emsp; → Kleisli Categories</a><br><a href=#categories-through-universal-construction>&emsp; → Categories through Universal Construction</a></div><br><hr>These are my lecture notes on Bartosz Milewski's course on category theory. These are not meant as a comprehensive guide but rather a loose collection of definitions and short summaries.<br>
<h2 id="general-stuff"> General stuff</h2>
A <strong>category</strong> is a collection of <strong>objects</strong> along with arrows, called <strong>morphisms</strong>, between those objects. It is therefore similar to a labeled directed graph.<br>

A category has two properties: <strong>composition of morphisms</strong> and <strong>identity</strong>. Composition in category theory is similar to composition of functions and behaves associatively. Identity means that every object has an <strong>identity morphism</strong>.<br>

<div class="image-center-wrapper"><img src="assets/category.svg"  class="inline-image image-center    "></div>
Morphisms between any two objects form a set called the <strong>hom-set</strong> denoted as \(C(a, b)\) where \(C\) is the category and \(a\) and \(b\) are objects. In higher-order categories morphisms don't form sets, they form objects in a category.
A <strong>groupoid</strong> is a category in which every morphism has an inverse.
A category whose objects form a set is called <strong>small</strong>, otherwise it's called <strong>large</strong>.
An algebraic group is a category with a single object (corresponding to the set of elements of the group).<br>
<br>

<div class="image-center-wrapper"><img src="assets/group-like-structures.png" style="width: 65%;" class="inline-image image-center    "></div><br>

A morphism \(f: a \rightarrow b\) is called
<ul>
	<li> an <strong>epimorphism</strong> (or <strong>epic</strong>) if it is right-cancellable, i.e. \(g_1 \circ f = g_2 \circ f\) implies \(g_1 = g_2\) for all \(c\) and all \(g_1, g_2: b \rightarrow c\)</li>
	<li> a <strong>monomorphism</strong> (or <strong>monic</strong>) if it is left-cancellable, i.e. \(f \circ g_1 = f \circ g_2\) implies \(g_1 = g_2\) for all \(c\) and all \(g_1, g_2: c \rightarrow a\)</li>
	<li> a <strong>bimorphism</strong> if it is both a monomorphism and an epimorphism</li>
	<li>An <strong>isomorphism</strong> if it has an inverse, i.e. if there exists an morphism \(f^{-1}: b \rightarrow a\) with \(f^{-1} \circ f = id_a\) and \(f \circ f^{-1} = id_b\).</li>
</ul><br>
<h2 id="set"> Set</h2>
<strong>Set</strong> (capitalized) is the category of sets and functions. <em>Set</em> is a category because there is an identity function for each set which becomes the identity morphism in <em>Set</em> and function composition (which becomes morphism composition in <em>Set</em>) is associative.<br>
<br>

In <em>Set</em>: surjective functions correspond to epimorphisms, injective functions correspond to monomorphisms and bijective functions correspond to bimorphisms. In <em>Set</em> all bimorphisms are isomorphisms since all bijective functions are invertible.<br>

Also notice the distinction between isomorphisms and bimorphisms. While in set theory a function that is bijective (both injective and surjective) is invertible, in category theory a bimorphism (which is both epic and monic) is not necessarily invertible (an isomorphism).<br>
<br>
<h2 id="category-theory-in-programming"> Category Theory in Programming</h2>
In a general sense, types in programming languages are sets:<br>
<br>

<ul>
	<li>Boolean represents the set \( \{True, False\}\)</li>
	<li>Int represents a subset of \(\mathbb{N}\)</li>
	<li>Float/Double represents a subset of \(\mathbb{Q}\)</li>
</ul><br>

If we go in the other direction we can ask which type in programming specific (special) sets correspond to:<br>
<br>
<h3 id="the-empty-set"> The Empty Set</h3>
The empty set does not correspond to any type in most imperative languages, it does however correspond to the type <em>Void</em> in Haskell (omitting the bottom element).<br>
<br>

We can define the following (uncallable) functions with Void in Haskell:<br>

<div class="code-wrapper"><pre><code>absurd :: Void → a
id_void :: Void → Void
</code></pre></div>
To call these functions we would have to supply a value to fill the Void-type parameter which we can not since there are no values of type Void. There exists no function with type <code>a → Void</code>. (If we called it with any argument, what could it return?)<br>

In mathematical logic, types/objects correspond to propositions and functions correspond to proofs. Therefore, the existence of a function between two propositions is equivalent to the existence of a proof.
This ties in well with the functions we defined above if we take the type Void to correspond to <em>False</em>.<br>
<br>

<ul>
    <li>The function <code>absurd :: Void → a</code> exists, this corresponds to the fact that we can proof anything from starting from false assumptions. ("All even numbers are primes \(\implies\) 20 is a prime")</li>
    <li>There exists no function of type <code>a → Void</code>, we cannot prove falsity. (You cannot prove something that's false, it has no proof)</li>
</ul><br>
<h3 id="the-singleton-set"> The Singleton Set</h3>
The (one element) singleton set has one element called <code>()</code> and we can build the <code>unit</code> function with it:<br>

<div class="code-wrapper"><pre><code>unit :: a → ()
</code></pre></div>
Furthermore we can define infinitely many functions of type <code>() → a</code>. These individual functions are constant. In this way we can express elements of a set as functions, or in category theory as morphisms.<br>

For example for type Bool we can define the functions<br>

<div class="code-wrapper"><pre><code>true :: () → Bool
true _ = True
false :: () → Bool
false _ = False
</code></pre></div>
Here we have expressed the elements of the type set of Bool as morphisms. In general the family of functions of type <code>() → a</code> correspond to picking elements of sets.<br>
<br>

Such an object <code>()</code>  (called <strong>generalized element</strong>) that allows us to view individual elements of a set as morphisms does not exist for every category. In general, category theory abstracts over elements and looks at sets, functions and other things from a higher perspective.<br>
<br>
<h3 id="the-two-element-set"> The Two-Element Set</h3>
The two element set is equivalent to the type <code>Bool</code>. It can also be defined as the sum of two units.
A function that returns a boolean is called a predicate.<br>
<br>
<h3 id="hask"> Hask</h3>
<strong>Hask</strong> (capitalized) is the category of types and functions in Haskell.<br>

Sidenote: There is an important difference between pure functions in programming and mathematical functions. Mathematical functions instantly evaluate to a certain result while functions in programming may not terminate. To avoid this issue a special element called <strong>bottom</strong> is added to all type-sets above and  and a non-terminating function is said to return this bottom value. Furthermore is a mathematical function only equivalent to a pure and total function in programming because it can't have side effects and is defined for every argument.<br>
<br>
<h3 id="weak-and-strong-typing"> Weak and Strong Typing</h3>
In a <em>Set</em>-like category with only a single object, any two function are composable. This is equivalent to a weakly typed language (or a language with only a single type). A strongly typed language is equivalent to a category with multiple objects.<br>

Therefore weak and strong typing aren't actually distinct concepts but instead is weak typing inside strong typing.<br>
<br>
<h2 id="other-categories"> Other Categories</h2><h3 id="the-category-$\varnothing$"> The Category \(\varnothing\)</h3>
The category \(\varnothing\) is the empty category. It contains no objects or morphisms.
Similar to the empty set or the number zero it is not very useful by itself. It however becomes useful in the context of other categories. <br>
<br>
<h3 id="free-categories"> Free Categories</h3>
Every finite directed graph can be turned into a category by adding a finite number of arrows.<br>
<br>

<ol>
    <li>Add identiy arrows to each node/object (if they do not exist yet).</li>
    <li>For every pair of composable arrows \(f, g\), add their composition \(g \circ f\). Keep in mind that because of associativity, not all compositions have to be added (\((f \circ g) \circ h = f \circ (g \circ h)\)).</li>
</ol><br>

This method of creating a category is called <strong>free construction</strong>. We are not imposing any additional constraints other than those required by the definition of a category. A category creating in this way is called a <strong>free category</strong>. <br>
<br>
<h3 id="monoids"> Monoids</h3>
A category is called a <strong>monoid</strong> if it contains exactly one object. This object has to have at least one morphism, the identity, but it can have more. It is related to algebraic monoids (in group theory) in the following way:<br>
<br>

An algebraic monoid is a set along with an associative operation and a neutral element. <br>
<br>

<ul>
    <li>Each element in the set along with the operation corresponds to a morphism from and to the single object.</li>
    <li>The neutral element corresponds to the identity morphism.</li>
    <li>The associativity of the operation corresponds to the associativity of morphism composition.</li>
</ul><br>

For example take the algebraic monoid of the natural numbers under addition. The associated monoid in category theory is a single object along with arrows, each corresponding to an element from \(A = \{+0, +1, +2, +3, \ldots\}\). We choose \(+0\) to be the identity morphism (\(\forall a \in A[ (+0)\circ a = a \land a\circ (+0) = a]\)). Since addition is associative, morphism composition is also associative.<br>
<br>

In this way we can always create a category monoid from an algebraic monoid and vice versa. <br>
<br>
<h3 id="thin-categories"> Thin Categories</h3>
A category is called a <strong>thin category</strong> if every hom-set is either the empty set or a singleton set. This means that for any pair of objects \((a, b)\) there is at most one arrow going from \(a\) to \(b\). In such a category every morphism is an epi- and monomorphism. (The definition of epi/monomorphism includes "[..] for every pair of morphisms between a and b [..]" but in a thin category there is at most one morphisms between any two objects.)<br>
<br>

In a thin category a bimorphism is not necessarily invertible (i.e. an isomorphism).<br>
<br>
<h3 id="orders"> Orders</h3>
<strong>Orders</strong> are categories where arrows are not necessarily functions but rather general relations.<br>

<ul>
    <li>A <strong>preorder</strong> is an order that is reflexive and composable (transitive). Every preorder is a thin category since for every pair of objects \((a, b)\) the hom-set is either empty (when \(a \nleq b\)) or a singleton set (when \(a \le	 b\)).</li>
    <li>A <strong>partial order</strong> is a preorder that is also antisymmetric. (It is therefore relexive, transitive and antisymmetric) A partial order induces a directed acyclic graph. A partially ordered set is called a poset.</li>
    <li>A <strong>total order</strong> is a partial order that is also connex (defined for any two objects - either \(a \le b\) or \(b \le a\)).</li>
</ul><br>

 \(\le\) is a total order on \(\mathbb{R}\). It satisfies the requirements for categories (associative composability and identity) since it is a transitive and reflexive relation (composition is associative because there can never be more than one arrow between a pair of objects). It furthermore is transitive, antisymmetric and defined for any two real numbers.<br>
<br>
<h3 id="kleisli-categories"> Kleisli Categories</h3>
<div class="image-center-wrapper"><img src="assets/kleisli-categories.png" style="width: 80%;" class="inline-image image-center    "></div>
Given a category consisting of objects \(a, b, c,\ldots\) and mappings \(x→(m,x)\) a Kleisli category can be constructed as above.<br>
<br>

The mapping from \(a\) to \((m, a)\) is called a <strong>monad</strong>. <br>
<br>
<h3 id="categories-through-universal-construction"> Categories through Universal Construction</h3>
A <strong>universal construction</strong> is a characterization of a particular type of object through its relationship with the rest of the universe. This allows us to define things like the empty set, singleton set, cartesian product, etc. in category theory, which in set theory are generally defined in terms of elements of sets.<br>
<br>

<strong>Example: Singleton set</strong><br>

The singleton set has the <strong>universal property</strong> that there is an arrow from every set to the singleton set. This property however is not uniquely characteristic of the singleton set since it in <em>Set</em> there are arrows from almost every set to every other set (apart from arrows from non-empty sets to void)
However to the singleton set there is always <em>exactly</em> one arrow from all other sets. Using this we can define the singleton set in category theory without using the notion of elements.<br>
<br>

<strong>Terminal objects</strong> generalize the relationship between the category <em>Set</em> and the singleton set.  A terminal object in a category is an object that has a unique arrow coming from any other object. Therefore a terminal object \((\,)\) satisfies the condition for existence of an incoming arrow \(\forall a\, \exists f\colon a →(\,)\) and the condition for uniqueness of the incoming arrow \(\forall f\colon a → (\,), g\colon a → (\,) \implies f=g\).<br>
<br>

Any sequence of arrows that lead from \(a\) to the terminal object \((\,)\) can be reduced through composition to a single arrow from \(a\) to \((\,)\). By the definition of the terminal object, this arrow is unique (for all paths, the composition is the same unique arrow). From this follows that all paths from \(a\) to \((\,)\) are in some sense equal.<br>
<br>

<strong>Example: Terminal objects in orders</strong><br>

Since orders are thin categories and in thin categories there can be at most one arrow from \(a\) to \(b\), only the condition for existence above is relevant. In an order there exists an arrow \(a → b\) if \(a \le b\). Therefore for \(\forall a\, \exists f\colon a →(\,)\) to hold we know that \(\forall a\colon a \le (\,)\) must be true. From this follows that the terminal object of an order is largest object in the order. Such an object does not necessarily exist (for example in \(\mathbb{N}\)).<br>
<br>

<strong>Example: Empty set</strong><br>

The empty set has the universal and uniquely defining property that it has exactly one outgoing arrow (the function <em>absurd</em>) to every object in <em>Set</em>.<br>
<br>

This motivates the definition of <strong>initial objects</strong> of a category (analogous to terminal objects). <br>
<br>

A category can have any number of terminal or initial objects.<br>
<br>

<strong>Terminal (or initial) objects are isomorphic</strong><br>

Let \(a\) and \(b\) be terminal objects of a category. Then by the definition of terminal objects there exist unique morphisms \(f\colon a→b\) and \(g\colon b→a\). Let \(h=g\circ f\). Therefore \(h\) goes from \(a\) to \(a\). By the definition of a terminal object there can only be a single arrow from \(a\) to \(a\) so the identity \(\text{id}_a\) and \(h\) must be the same. Analogous for \(k=f\circ g\).<br>
<br>

Therefore \(f \circ g = \text{id}_b\) and \(g \circ f = \text{id}_a\) which is the definition of an isomorphism. This isomorphism is unique since \(f\) and \(g\) are unique.<section id="article_footer"><div class="further-reading"><h2>Further Reading</h2><br><ul><li><a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Category Theory lectures by Bartosz Milewski</a></li><li><a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category Theory for Programmers, Book by Bartosz Milewski</a></li><li><a href="https://en.wikipedia.org/wiki/Category_theory">Wikipedia (Category Theory)</a></li></ul></div></section>
      </span>

      <!--<div id="disqus_thread"></div>


      <script>
          /**
           *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
           *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
           */

          var disqus_config = function () {
              this.page.url = "https://dominikschmidt.xyz/category-theory-notes";  // Replace PAGE_URL with your page's canonical URL variable
              this.page.identifier = "category-theory-notes"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
          };

          (function() {  // DON'T EDIT BELOW THIS LINE
              var d = document, s = d.createElement('script');

              s.src = 'https://dominikschmidtxyz.disqus.com/embed.js';

              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
          })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </div>-->

  <br><br>

  <!--<footer class="container">
    <span><i class="fas fa-copyright"></i> 2018 Dominik Schmidt</span><br>
  </footer>-

  <br>-->

<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
